# Mundi ì—”ì§„ ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œ ë¬¸ì„œ

## ğŸ“‹ ëª©ì°¨
1. [ì‹œìŠ¤í…œ ê°œìš”](#ì‹œìŠ¤í…œ-ê°œìš”)
2. [ì•„í‚¤í…ì²˜](#ì•„í‚¤í…ì²˜)
3. [í•µì‹¬ ì»´í¬ë„ŒíŠ¸](#í•µì‹¬-ì»´í¬ë„ŒíŠ¸)
4. [ë°ì´í„° êµ¬ì¡°](#ë°ì´í„°-êµ¬ì¡°)
5. [ì• ë‹ˆë©”ì´ì…˜ ë…¸ë“œ ì‹œìŠ¤í…œ](#ì• ë‹ˆë©”ì´ì…˜-ë…¸ë“œ-ì‹œìŠ¤í…œ)
6. [State Machine](#state-machine)
7. [ë¸”ë Œë”© ì‹œìŠ¤í…œ](#ë¸”ë Œë”©-ì‹œìŠ¤í…œ)
8. [ì‚¬ìš© ë°©ë²•](#ì‚¬ìš©-ë°©ë²•)
9. [í™•ì¥ ê°€ì´ë“œ](#í™•ì¥-ê°€ì´ë“œ)

---

## ì‹œìŠ¤í…œ ê°œìš”

Mundi ì—”ì§„ì˜ ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œì€ **Unreal Engine ìŠ¤íƒ€ì¼**ì˜ êµ¬ì¡°ë¥¼ ë”°ë¥´ë©°, ë‹¤ìŒ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤:

### ì£¼ìš” ê¸°ëŠ¥
- âœ… **ìŠ¤ì¼ˆë ˆíƒˆ ì• ë‹ˆë©”ì´ì…˜**: ë³¸ ê¸°ë°˜ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
- âœ… **State Machine**: ìƒíƒœ ê¸°ë°˜ ì• ë‹ˆë©”ì´ì…˜ ì „í™˜
- âœ… **ë¸”ë Œë”©**: ì• ë‹ˆë©”ì´ì…˜ ê°„ ë¶€ë“œëŸ¬ìš´ ì „í™˜
- âœ… **ì• ë‹ˆë©”ì´ì…˜ ë…¸ë“œ ê·¸ë˜í”„**: í™•ì¥ ê°€ëŠ¥í•œ ë…¸ë“œ ê¸°ë°˜ ì‹œìŠ¤í…œ
- âœ… **Transition Rules**: ì¡°ê±´ ê¸°ë°˜ ìƒíƒœ ì „í™˜
- âœ… **Animation Sequence**: FBXì—ì„œ ë¡œë“œí•œ ì• ë‹ˆë©”ì´ì…˜ ë°ì´í„°
- âœ… **Two-Way Blend**: ë‘ ì• ë‹ˆë©”ì´ì…˜ ê°„ ë³´ê°„
- âœ… **Loop/Non-Loop ì§€ì›**: ë£¨í”„ ë° ì¼íšŒì„± ì¬ìƒ

### ì‹œìŠ¤í…œ íŠ¹ì§•
- **Unreal Engine í˜¸í™˜ êµ¬ì¡°**: UAnimInstance, AnimNode ë“± ì¹œìˆ™í•œ API
- **ë°ì´í„° ê¸°ë°˜ ì„¤ê³„**: ì• ë‹ˆë©”ì´ì…˜ ë°ì´í„°ì™€ ë¡œì§ ë¶„ë¦¬
- **í™•ì¥ ê°€ëŠ¥**: ìƒˆë¡œìš´ ë…¸ë“œ íƒ€ì… ì¶”ê°€ ìš©ì´
- **CPU/GPU ìŠ¤í‚¤ë‹ ì§€ì›**: ìœ ì—°í•œ ë Œë”ë§ íŒŒì´í”„ë¼ì¸

---

## ì•„í‚¤í…ì²˜

### ì „ì²´ êµ¬ì¡°ë„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    USkeletalMeshComponent                    â”‚
â”‚  - ìŠ¤ì¼ˆë ˆíƒˆ ë©”ì‹œ ë Œë”ë§                                        â”‚
â”‚  - ì• ë‹ˆë©”ì´ì…˜ ëª¨ë“œ ê´€ë¦¬ (SingleNode / AnimBlueprint)           â”‚
â”‚  - Pose ê³„ì‚° ë° ìŠ¤í‚¤ë‹                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ owns
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      UAnimInstance                           â”‚
â”‚  - ì• ë‹ˆë©”ì´ì…˜ ë¡œì§ ê´€ë¦¬                                        â”‚
â”‚  - Update/Evaluate ë¼ì´í”„ì‚¬ì´í´                               â”‚
â”‚  - Transition Rule ê´€ë¦¬                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ contains
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  FAnimNode_StateMachine                      â”‚
â”‚  - State ê´€ë¦¬ (States, Transitions)                         â”‚
â”‚  - í˜„ì¬ State ì¶”ì                                            â”‚
â”‚  - Transition ì‹¤í–‰                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ contains
                 â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   FAnimState  â”‚
         â”‚  - ìƒíƒœ ì •ì˜   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ contains
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   FAnimNode_Sequence                         â”‚
â”‚  - UAnimationSequence ì¬ìƒ                                   â”‚
â”‚  - ì‹œê°„ ì—…ë°ì´íŠ¸                                              â”‚
â”‚  - Pose í‰ê°€                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ uses
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   UAnimationSequence                         â”‚
â”‚  - ì• ë‹ˆë©”ì´ì…˜ ë°ì´í„° (UAnimDataModel)                         â”‚
â”‚  - FBXì—ì„œ ë¡œë“œ                                              â”‚
â”‚  - ë°”ì´ë„ˆë¦¬ ìºì‹± (.uanim)                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ë°ì´í„° íë¦„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FBX íŒŒì¼    â”‚ â”€â”€> â”‚ FBXLoader    â”‚ â”€â”€> â”‚ .uanim ìºì‹œ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
                                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    UAnimationSequence                        â”‚
â”‚  - UAnimDataModel (ë³¸ ì• ë‹ˆë©”ì´ì…˜ íŠ¸ë™)                        â”‚
â”‚  - FSkeleton (ë¼ˆëŒ€ êµ¬ì¡°)                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼ (Sample at Time T)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      FPoseContext                            â”‚
â”‚  - TArray<FTransform> EvaluatedPoses                        â”‚
â”‚  - (ê° ë³¸ì˜ ë¡œì»¬ Transform)                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼ (Blending, State Machine ì²˜ë¦¬)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              USkeletalMeshComponent::Pose                    â”‚
â”‚  - LocalSpace â†’ ComponentSpace â†’ FinalMatrices              â”‚
â”‚  - GPU/CPU Skinning                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## í•µì‹¬ ì»´í¬ë„ŒíŠ¸

### 1. USkeletalMeshComponent

**ì—­í• **: ìŠ¤ì¼ˆë ˆíƒˆ ë©”ì‹œ ë Œë”ë§ ë° ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œ í†µí•©

**ì£¼ìš” ê¸°ëŠ¥**:
- ì• ë‹ˆë©”ì´ì…˜ ëª¨ë“œ ê´€ë¦¬ (`EAnimationMode`)
- AnimInstance ì†Œìœ  ë° ê´€ë¦¬
- Pose ê³„ì‚° (LocalSpace â†’ ComponentSpace â†’ FinalMatrices)
- ë³¸ Transform ì¡°ì‘ API

**ì• ë‹ˆë©”ì´ì…˜ ëª¨ë“œ**:
```cpp
enum class EAnimationMode : uint8
{
    AnimationSingleNode,    // ë‹¨ì¼ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
    AnimationBlueprint      // AnimInstance ê¸°ë°˜ ë³µì¡í•œ ë¡œì§
};
```

**í•µì‹¬ API**:
```cpp
// ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œ
void SetAnimInstanceClass(UAnimInstance* NewAnimInstanceClass);
UAnimInstance* GetAnimInstanceClass() const;
void SetAnimationMode(EAnimationMode InAnimationMode);

// Pose ê´€ë¦¬
void ForceRecomputePose();
TArray<FTransform>& GetLocalSpacePose();

// ë³¸ Transform ì¡°ì‘
void SetBoneLocalTransform(int32 BoneIndex, const FTransform& NewLocalTransform);
FTransform GetBoneLocalTransform(int32 BoneIndex) const;
FTransform GetBoneWorldTransform(int32 BoneIndex);
```

---

### 2. UAnimInstance

**ì—­í• **: ì• ë‹ˆë©”ì´ì…˜ ë¡œì§ì˜ ì¤‘ì‹¬, State Machineê³¼ Transition Rule ê´€ë¦¬

**ë¼ì´í”„ì‚¬ì´í´**:
```cpp
// 1. ì´ˆê¸°í™” (ìµœì´ˆ 1íšŒ)
void Initialize();

// 2. ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸
void UpdateAnimation(float DeltaTime);
    â”œâ”€> NativeUpdateAnimation(float DeltaSeconds);  // íŒŒë¼ë¯¸í„° ì—…ë°ì´íŠ¸
    â””â”€> EvaluateAnimation();                        // Pose ê³„ì‚°
```

**í•µì‹¬ ë©¤ë²„**:
```cpp
FAnimNode_StateMachine ASM;              // Animation State Machine
FAnimNode_Base* RootNode = nullptr;      // ë£¨íŠ¸ ì• ë‹ˆë©”ì´ì…˜ ë…¸ë“œ
FPoseContext CurrentPose;                // í˜„ì¬ Pose
TArray<UAnimNodeTransitionRule*> TransitionRules;  // Transition Rule ê´€ë¦¬
```

**API**:
```cpp
// Transition Rule ê´€ë¦¬
void AddTransitionRule(UAnimNodeTransitionRule* InRule);
void RemoveTransitionRule(const FName& RuleName);
UAnimNodeTransitionRule* FindTransitionRuleByName(const FName& RuleName) const;

// State Machine ì´ˆê¸°í™”
void InitializeAnimationStateMachine();
```

---

### 3. UAnimSingleNodeInstance

**ì—­í• **: ë‹¨ì¼ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒì„ ìœ„í•œ ê°„ì†Œí™”ëœ AnimInstance

**íŠ¹ì§•**:
- State Machine ì—†ì´ í•˜ë‚˜ì˜ ì• ë‹ˆë©”ì´ì…˜ë§Œ ì¬ìƒ
- ê°„ë‹¨í•œ ë£¨í”„/ë…¼ë£¨í”„ ì œì–´
- ë¹ ë¥¸ í”„ë¡œí† íƒ€ì´í•‘ì— ìœ ìš©

**API**:
```cpp
void SetAnimation(UAnimationAsset* NewAnimation);
void PlayAnimation(UAnimationAsset* NewAnimToPlay, bool bLooping = true);
void SetPlaybackSpeed(float InSpeed);
UAnimationAsset* GetCurrentAnimation() const;
```

---

## ë°ì´í„° êµ¬ì¡°

### 1. ì• ë‹ˆë©”ì´ì…˜ ë°ì´í„° ê³„ì¸µ

```
UAnimationSequence (ë¦¬ì†ŒìŠ¤)
    â””â”€> UAnimDataModel (ë°ì´í„° ì»¨í…Œì´ë„ˆ)
            â””â”€> TArray<FBoneAnimationTrack> (ë³¸ë³„ íŠ¸ë™)
                    â””â”€> FRawAnimSequenceTrack (í‚¤í”„ë ˆì„ ë°ì´í„°)
                            â”œâ”€> TArray<FVector> PosKeys    (ìœ„ì¹˜)
                            â”œâ”€> TArray<FVector4> RotKeys   (íšŒì „, Quaternion)
                            â””â”€> TArray<FVector> ScaleKeys  (ìŠ¤ì¼€ì¼)
```

### 2. FRawAnimSequenceTrack

**ì—­í• **: í•œ ë³¸ì˜ ì• ë‹ˆë©”ì´ì…˜ í‚¤í”„ë ˆì„ ì €ì¥

```cpp
struct FRawAnimSequenceTrack
{
    TArray<FVector> PosKeys;    // ìœ„ì¹˜ í‚¤í”„ë ˆì„
    TArray<FVector4> RotKeys;   // íšŒì „ í‚¤í”„ë ˆì„ (Quaternion)
    TArray<FVector> ScaleKeys;  // ìŠ¤ì¼€ì¼ í‚¤í”„ë ˆì„
};
```

**íŠ¹ì§•**:
- ê° í‚¤í”„ë ˆì„ì€ ì‹œê°„ì— ë”°ë¼ ì •ë ¬
- ë°”ì´ë„ˆë¦¬ ì§ë ¬í™” ì§€ì› (`operator<<`)
- Interpolationì„ í†µí•œ ì¤‘ê°„ ê°’ ê³„ì‚°

### 3. FBoneAnimationTrack

**ì—­í• **: íŠ¹ì • ë³¸ì— ëŒ€í•œ ì• ë‹ˆë©”ì´ì…˜ íŠ¸ë™

```cpp
struct FBoneAnimationTrack
{
    FName Name;                        // ë³¸ ì´ë¦„ (ex: "Spine", "Head")
    FRawAnimSequenceTrack InternalTrack; // ì‹¤ì œ ì• ë‹ˆë©”ì´ì…˜ ë°ì´í„°
};
```

### 4. UAnimDataModel

**ì—­í• **: ì• ë‹ˆë©”ì´ì…˜ ë©”íƒ€ë°ì´í„° ë° íŠ¸ë™ ê´€ë¦¬

```cpp
class UAnimDataModel : public UObject
{
    TArray<FBoneAnimationTrack> BoneAnimationTracks; // ëª¨ë“  ë³¸ì˜ íŠ¸ë™
    float PlayLength;       // ì• ë‹ˆë©”ì´ì…˜ ì´ ê¸¸ì´ (ì´ˆ)
    float FrameRate;        // í”„ë ˆì„ ë ˆì´íŠ¸ (fps)
    int32 NumberOfFrames;   // ì´ í”„ë ˆì„ ìˆ˜
    int32 NumberOfKeys;     // ì´ í‚¤í”„ë ˆì„ ìˆ˜
};
```

**API**:
```cpp
const FBoneAnimationTrack* FindTrackByBone(const FName& BoneName);
float GetPlayLength() const;
float GetFrameRate() const;
int32 GetNumberOfFrames() const;
```

### 5. FPoseContext

**ì—­í• **: íŠ¹ì • ì‹œì ì˜ ë³¸ í¬ì¦ˆ (Transform ë°°ì—´)

```cpp
struct FPoseContext
{
    const FSkeleton* Skeleton = nullptr;      // ìŠ¤ì¼ˆë ˆí†¤ ì°¸ì¡°
    TArray<FTransform> EvaluatedPoses;       // ê° ë³¸ì˜ Transform
};
```

**ì‚¬ìš© íŒ¨í„´**:
```cpp
// Pose ìƒì„±
FPoseContext Pose(Skeleton);

// ì• ë‹ˆë©”ì´ì…˜ í‰ê°€
AnimSequence->EvaluatePose(Time, Pose);

// Pose ì‚¬ìš©
for (int i = 0; i < Pose.EvaluatedPoses.Num(); i++)
{
    FTransform BoneTransform = Pose.EvaluatedPoses[i];
    // ...
}
```

---

## ì• ë‹ˆë©”ì´ì…˜ ë…¸ë“œ ì‹œìŠ¤í…œ

### ë…¸ë“œ ë² ì´ìŠ¤ ì¸í„°í˜ì´ìŠ¤

```cpp
struct FAnimNode_Base {
    virtual void Update(const FAnimationUpdateContext& Context) = 0;  // ì‹œê°„ ì—…ë°ì´íŠ¸
    virtual void Evaluate(FPoseContext& Output) = 0;                  // Pose ê³„ì‚°
    virtual ~FAnimNode_Base() = default;
};
```

### 1. FAnimNode_Sequence

**ì—­í• **: ë‹¨ì¼ ì• ë‹ˆë©”ì´ì…˜ ì‹œí€€ìŠ¤ ì¬ìƒ

```cpp
struct FAnimNode_Sequence : FAnimNode_Base
{
    UAnimationSequence* Sequence = nullptr;  // ì¬ìƒí•  ì‹œí€€ìŠ¤
    float CurrentTime = 0.0f;                // í˜„ì¬ ì¬ìƒ ì‹œê°„
    float PlayRate = 1.0f;                   // ì¬ìƒ ì†ë„
    bool bLooping = true;                    // ë£¨í”„ ì—¬ë¶€

    void SetSequence(UAnimationSequence* InSeq, bool bInLoop = true);
    void SetLooping(bool bInLooping);

    virtual void Update(const FAnimationUpdateContext& Context) override;
    virtual void Evaluate(FPoseContext& Output) override;
};
```

**Update ë¡œì§**:
```cpp
void FAnimNode_Sequence::Update(const FAnimationUpdateContext& Context)
{
    if (!Sequence) return;

    const float Length = Sequence->GetPlayLength();
    CurrentTime += Context.DeltaTime * PlayRate;

    if (bLooping) {
        CurrentTime = std::fmod(CurrentTime, Length);  // ë£¨í”„
    } else {
        CurrentTime = FMath::Clamp(CurrentTime, 0.0f, Length);  // í´ë¨í”„
    }
}
```

**Evaluate ë¡œì§**:
```cpp
void FAnimNode_Sequence::Evaluate(FPoseContext& Output)
{
    if (!Sequence) return;
    Sequence->EvaluatePose(CurrentTime, Output);  // í˜„ì¬ ì‹œê°„ì˜ Pose ê³„ì‚°
}
```

---

### 2. FAnimNode_TwoWayBlend

**ì—­í• **: ë‘ ì• ë‹ˆë©”ì´ì…˜ ê°„ ë¸”ë Œë”©

```cpp
struct FAnimNode_TwoWayBlend : FAnimNode_Base
{
    FAnimNode_Base* From = nullptr;   // ì‹œì‘ ë…¸ë“œ
    FAnimNode_Base* To = nullptr;     // ëª©í‘œ ë…¸ë“œ

    float Alpha = 0.f;                // ë¸”ë Œë“œ ê°€ì¤‘ì¹˜ (0 â†’ From, 1 â†’ To)
    float BlendTime = 0.2f;           // ë¸”ë Œë“œ ì†Œìš” ì‹œê°„
    float BlendTimeElapsed = 0.f;     // ê²½ê³¼ ì‹œê°„
    bool bIsBlending = false;         // ë¸”ë Œë”© ì¤‘ ì—¬ë¶€

    virtual void Update(const FAnimationUpdateContext& Context) override;
    virtual void Evaluate(FPoseContext& Output) override;
    void Blend(const FPoseContext& Start, const FPoseContext& End, float Alpha, FPoseContext& Out);
};
```

**Update ë¡œì§**:
```cpp
void FAnimNode_TwoWayBlend::Update(const FAnimationUpdateContext& Context)
{
    // ë‘ ë…¸ë“œ ëª¨ë‘ ì—…ë°ì´íŠ¸
    if (From) From->Update(Context);
    if (To) To->Update(Context);

    // ë¸”ë Œë”© ì¤‘ì´ë©´ Alpha ì¦ê°€
    if (bIsBlending)
    {
        BlendTimeElapsed += Context.DeltaTime;
        Alpha = FMath::Clamp(BlendTimeElapsed / BlendTime, 0.f, 1.f);

        if (BlendTimeElapsed >= BlendTime)
            bIsBlending = false;  // ë¸”ë Œë”© ì™„ë£Œ
    }
}
```

**Blend ë¡œì§**:
```cpp
void FAnimNode_TwoWayBlend::Blend(const FPoseContext& Start, const FPoseContext& End,
                                   float Alpha, FPoseContext& Out)
{
    const int32 BoneCnt = std::min(Start.EvaluatedPoses.Num(), End.EvaluatedPoses.Num());
    Out.EvaluatedPoses.SetNum(BoneCnt);

    for (int i = 0; i < BoneCnt; i++)
    {
        // Transform Lerp (ìœ„ì¹˜, íšŒì „, ìŠ¤ì¼€ì¼ ë³´ê°„)
        Out.EvaluatedPoses[i] = FTransform::Lerp(Start.EvaluatedPoses[i],
                                                   End.EvaluatedPoses[i],
                                                   Alpha);
    }
}
```

---

## State Machine

### FAnimState

**ì—­í• **: í•˜ë‚˜ì˜ ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ í‘œí˜„

```cpp
struct FAnimState
{
    FName Name{};                                 // State ì´ë¦„ (ex: "Idle", "Walk", "Run")
    uint32 Index{};                               // StateMachineì—ì„œì˜ ì¸ë±ìŠ¤
    TArray<FAnimNode_Sequence> AnimSequenceNodes; // ì´ Stateì˜ ì• ë‹ˆë©”ì´ì…˜ë“¤

    FAnimNode_Sequence* AddAnimSequence(UAnimationSequence* AnimSequence, bool bLoop = true);
};
```

**ì‚¬ìš© ì˜ˆì‹œ**:
```cpp
FAnimState* IdleState = StateMachine->AddState("Idle");
IdleState->AddAnimSequence(IdleAnimation, true);  // ë£¨í”„ ì• ë‹ˆë©”ì´ì…˜
```

---

### FAnimStateTransition

**ì—­í• **: ìƒíƒœ ê°„ ì „í™˜ ì •ì˜

```cpp
struct FAnimStateTransition
{
    FAnimState* SourceState = nullptr;           // ì¶œë°œ ìƒíƒœ
    FAnimState* TargetState = nullptr;           // ëª©í‘œ ìƒíƒœ
    uint32 Index{};                              // Transition ì¸ë±ìŠ¤

    bool CanEnterTransition = false;             // ì „í™˜ ê°€ëŠ¥ í”Œë˜ê·¸

    // Transition Rule ì—°ê²°
    UAnimNodeTransitionRule* AssociatedRule = nullptr;
    FDelegateHandle DelegateHandle;

    float BlendTime = 0.2f;                      // ë¸”ë Œë“œ ì‹œê°„

    void TriggerTransition();                    // ì „í™˜ íŠ¸ë¦¬ê±°
    void SetBlendTime(float InBlendTime);
};
```

**Transition ì¡°ê±´ í‰ê°€**:
```cpp
// Transition Ruleì´ ì¡°ê±´ ì¶©ì¡± ì‹œ Delegate í˜¸ì¶œ
if (Rule->CheckTransitionRule())
{
    Transition->TriggerTransition();  // CanEnterTransition = true
}
```

---

### FAnimNode_StateMachine

**ì—­í• **: State Machine ê´€ë¦¬ ë° ì‹¤í–‰

```cpp
struct FAnimNode_StateMachine : FAnimNode_Base
{
    TArray<FAnimState*> States;                   // ëª¨ë“  State
    TArray<FAnimStateTransition*> Transitions;    // ëª¨ë“  Transition

    FAnimState* CurrentState = nullptr;           // í˜„ì¬ í™œì„± State

    // Transition ìƒíƒœ
    bool bIsInTransition = false;
    FAnimStateTransition* CurrentTransition = nullptr;
    float TransitionElapsed = 0.f;
    float TransitionDuration = 0.f;
    FAnimNode_TwoWayBlend TransitionBlendNode;   // ë¸”ë Œë”© ë…¸ë“œ

    virtual void Update(const FAnimationUpdateContext& Context) override;
    virtual void Evaluate(FPoseContext& Output) override;
};
```

**í•µì‹¬ API**:
```cpp
// State ê´€ë¦¬
FAnimState* AddState(const FName& StateName);
void DeleteState(const FName& TargetName);
FAnimState* GetCurrentState() const;

// Transition ê´€ë¦¬
FAnimStateTransition* AddTransition(const FName& SourceName, const FName& TargetName);
FAnimStateTransition* AddTransition(const FName& SourceName, const FName& TargetName,
                                     UAnimNodeTransitionRule* TransitionRule);
void DeleteTransition(const FName& SourceName, const FName& TargetName);
```

**Update ë¡œì§ (í•µì‹¬)**:
```cpp
void FAnimNode_StateMachine::Update(const FAnimationUpdateContext& Context)
{
    if (!CurrentState) return;

    // 1. Transition ì§„í–‰ ì¤‘ì¸ ê²½ìš°
    if (bIsInTransition && CurrentTransition)
    {
        TransitionElapsed += Context.DeltaTime;

        // ë¸”ë Œë“œ ë…¸ë“œ ì—…ë°ì´íŠ¸
        TransitionBlendNode.Update(Context);

        // Transition ì™„ë£Œ í™•ì¸
        if (TransitionElapsed >= TransitionDuration)
        {
            CurrentState = CurrentTransition->TargetState;  // State ì „í™˜!
            bIsInTransition = false;
            CurrentTransition->CanEnterTransition = false;
        }
        return;
    }

    // 2. í˜„ì¬ Stateì˜ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
    for (auto& SeqNode : CurrentState->AnimSequenceNodes)
    {
        SeqNode.Update(Context);
    }

    // 3. Transition ì¡°ê±´ ì²´í¬
    for (auto* Transition : Transitions)
    {
        if (Transition->SourceState == CurrentState &&
            Transition->CanEnterTransition)
        {
            // Transition ì‹œì‘!
            bIsInTransition = true;
            CurrentTransition = Transition;
            TransitionElapsed = 0.f;
            TransitionDuration = Transition->BlendTime;

            // ë¸”ë Œë“œ ë…¸ë“œ ì„¤ì •
            TransitionBlendNode.From = &CurrentState->AnimSequenceNodes[0];
            TransitionBlendNode.To = &Transition->TargetState->AnimSequenceNodes[0];
            TransitionBlendNode.bIsBlending = true;
            TransitionBlendNode.BlendTimeElapsed = 0.f;
            TransitionBlendNode.BlendTime = Transition->BlendTime;
            break;
        }
    }
}
```

**Evaluate ë¡œì§**:
```cpp
void FAnimNode_StateMachine::Evaluate(FPoseContext& Output)
{
    // Transition ì¤‘: ë¸”ë Œë“œ ë…¸ë“œ í‰ê°€
    if (bIsInTransition)
    {
        TransitionBlendNode.Evaluate(Output);
    }
    // ì¼ë°˜ State: ì²« ë²ˆì§¸ ì‹œí€€ìŠ¤ í‰ê°€
    else if (CurrentState && !CurrentState->AnimSequenceNodes.empty())
    {
        CurrentState->AnimSequenceNodes[0].Evaluate(Output);
    }
}
```

---

## ë¸”ë Œë”© ì‹œìŠ¤í…œ

### Transform Lerp

ì• ë‹ˆë©”ì´ì…˜ ë¸”ë Œë”©ì˜ í•µì‹¬ì€ **Transform Lerp (ì„ í˜• ë³´ê°„)**ì…ë‹ˆë‹¤:

```cpp
FTransform FTransform::Lerp(const FTransform& A, const FTransform& B, float Alpha)
{
    FTransform Result;

    // 1. ìœ„ì¹˜ Lerp
    Result.Position = FVector::Lerp(A.Position, B.Position, Alpha);

    // 2. íšŒì „ Slerp (Quaternion)
    Result.Rotation = FQuaternion::Slerp(A.Rotation, B.Rotation, Alpha);

    // 3. ìŠ¤ì¼€ì¼ Lerp
    Result.Scale = FVector::Lerp(A.Scale, B.Scale, Alpha);

    return Result;
}
```

### ë¸”ë Œë”© íƒ€ì…

| íƒ€ì… | ì„¤ëª… | ì‚¬ìš© ì˜ˆì‹œ |
|------|------|-----------|
| **Two-Way Blend** | ë‘ ì• ë‹ˆë©”ì´ì…˜ ê°„ ë³´ê°„ | Idle â†’ Walk ì „í™˜ |
| **Time-based Blend** | ì‹œê°„ì— ë”°ë¥¸ ì ì§„ì  ì „í™˜ | ë¶€ë“œëŸ¬ìš´ ìƒíƒœ ì „í™˜ |
| **Alpha Blend** | ê°€ì¤‘ì¹˜ ê¸°ë°˜ í˜¼í•© | AimOffset, Layered Animation |

### Transition ë¸”ë Œë”© ì˜ˆì‹œ

```
Idle State (100%)  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Walk State (100%)
     â”‚                                        â”‚
     â”‚                                        â”‚
     â””â”€â”€â”€ 0.2ì´ˆ Transition êµ¬ê°„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          Alpha: 0.0 â†’ 1.0

ì‹œê°„:  0.0s        0.1s        0.2s
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Idle â”‚ 100%        â”‚ 50%        â”‚ 0%
Walk â”‚ 0%          â”‚ 50%        â”‚ 100%
```

---

## ì‚¬ìš© ë°©ë²•

### 1. ë‹¨ì¼ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ (AnimationSingleNode)

**ì‹œë‚˜ë¦¬ì˜¤**: ê°„ë‹¨í•œ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ

```cpp
// 1. SkeletalMeshComponent ìƒì„±
USkeletalMeshComponent* SkelComp = NewObject<USkeletalMeshComponent>();
SkelComp->SetSkeletalMesh("Character.fbx");

// 2. ì• ë‹ˆë©”ì´ì…˜ ëª¨ë“œ ì„¤ì •
SkelComp->SetAnimationMode(EAnimationMode::AnimationSingleNode);

// 3. AnimSingleNodeInstance ìƒì„± ë° ì„¤ì •
UAnimSingleNodeInstance* AnimInstance = NewObject<UAnimSingleNodeInstance>();
AnimInstance->SetSkeletalComponent(SkelComp);
SkelComp->SetAnimInstanceClass(AnimInstance);

// 4. ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
UAnimationSequence* IdleAnim = RESOURCE.Load<UAnimationSequence>("Idle");
AnimInstance->PlayAnimation(IdleAnim, true);  // ë£¨í”„ ì¬ìƒ
```

---

### 2. State Machine ì‚¬ìš© (AnimationBlueprint)

**ì‹œë‚˜ë¦¬ì˜¤**: Idle, Walk, Run ìƒíƒœ ì „í™˜

```cpp
// 1. Custom AnimInstance í´ë˜ìŠ¤ ìƒì„±
class UMyAnimInstance : public UAnimInstance
{
protected:
    virtual void NativeUpdateAnimation(float DeltaSeconds) override
    {
        UAnimInstance::NativeUpdateAnimation(DeltaSeconds);

        // ì—¬ê¸°ì„œ ê²Œì„ ë¡œì§ ê¸°ë°˜ íŒŒë¼ë¯¸í„° ì—…ë°ì´íŠ¸
        float Speed = GetOwnerVelocity().Length();
        // ...
    }
};

// 2. State Machine ì´ˆê¸°í™”
void UMyAnimInstance::InitializeAnimationStateMachine()
{
    // State ì¶”ê°€
    FAnimState* IdleState = ASM.AddState("Idle");
    FAnimState* WalkState = ASM.AddState("Walk");
    FAnimState* RunState = ASM.AddState("Run");

    // ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
    IdleState->AddAnimSequence(RESOURCE.Load<UAnimationSequence>("Idle_Anim"), true);
    WalkState->AddAnimSequence(RESOURCE.Load<UAnimationSequence>("Walk_Anim"), true);
    RunState->AddAnimSequence(RESOURCE.Load<UAnimationSequence>("Run_Anim"), true);

    // Transition Rule ìƒì„±
    UFloatComparisonRule* IdleToWalk = NewObject<UFloatComparisonRule>();
    IdleToWalk->SetRuleName("IdleToWalk");
    IdleToWalk->SetThreshold(0.1f);
    IdleToWalk->SetOperator(UAnimNodeTransitionRule::ComparisonOperator::GreaterThan);

    // Transition ì¶”ê°€
    ASM.AddTransition("Idle", "Walk", IdleToWalk);
    ASM.AddTransition("Walk", "Run", WalkToRunRule);
    ASM.AddTransition("Run", "Walk", RunToWalkRule);

    // ì´ˆê¸° State ì„¤ì •
    ASM.CurrentState = IdleState;
}
```

---

### 3. Transition Rule êµ¬í˜„

**ì‹œë‚˜ë¦¬ì˜¤**: ì†ë„ ê¸°ë°˜ ìƒíƒœ ì „í™˜

```cpp
// FloatComparisonRule: ì‹¤ì œ êµ¬í˜„ ì˜ˆì‹œ
class UFloatComparisonRule : public UAnimNodeTransitionRule
{
public:
    void SetValue(float* InValuePtr) { ValuePtr = InValuePtr; }
    void SetThreshold(float InThreshold) { Threshold = InThreshold; }
    void SetOperator(ComparisonOperator Op) { Operator = Op; }

    virtual bool CheckTransitionRule() override
    {
        if (!ValuePtr) return false;

        switch (Operator)
        {
        case ComparisonOperator::GreaterThan:
            return *ValuePtr > Threshold;
        case ComparisonOperator::LessThan:
            return *ValuePtr < Threshold;
        case ComparisonOperator::GreaterThanOrEqualTo:
            return *ValuePtr >= Threshold;
        case ComparisonOperator::LessThanOrEqualTo:
            return *ValuePtr <= Threshold;
        }
        return false;
    }

private:
    float* ValuePtr = nullptr;
    float Threshold = 0.0f;
    ComparisonOperator Operator;
};

// ì‚¬ìš©
float PlayerSpeed = 0.0f;  // ê²Œì„ ë¡œì§ì—ì„œ ì—…ë°ì´íŠ¸

UFloatComparisonRule* Rule = NewObject<UFloatComparisonRule>();
Rule->SetValue(&PlayerSpeed);
Rule->SetThreshold(5.0f);
Rule->SetOperator(ComparisonOperator::GreaterThan);

AddTransitionRule(Rule);
```

---

### 4. ì»¤ìŠ¤í…€ ì• ë‹ˆë©”ì´ì…˜ ë…¸ë“œ

**ì‹œë‚˜ë¦¬ì˜¤**: Additive Animation êµ¬í˜„

```cpp
struct FAnimNode_Additive : FAnimNode_Base
{
    FAnimNode_Base* BaseNode = nullptr;      // ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜
    FAnimNode_Base* AdditiveNode = nullptr;  // ì¶”ê°€ ì• ë‹ˆë©”ì´ì…˜
    float AdditiveAlpha = 1.0f;              // ì¶”ê°€ ê°•ë„

    virtual void Update(const FAnimationUpdateContext& Context) override
    {
        if (BaseNode) BaseNode->Update(Context);
        if (AdditiveNode) AdditiveNode->Update(Context);
    }

    virtual void Evaluate(FPoseContext& Output) override
    {
        if (!BaseNode || !AdditiveNode) return;

        FPoseContext BasePose(Output.Skeleton);
        FPoseContext AdditivePose(Output.Skeleton);

        BaseNode->Evaluate(BasePose);
        AdditiveNode->Evaluate(AdditivePose);

        // Additive ì ìš©
        for (int i = 0; i < BasePose.EvaluatedPoses.Num(); i++)
        {
            FTransform Delta = AdditivePose.EvaluatedPoses[i];
            Output.EvaluatedPoses[i] = BasePose.EvaluatedPoses[i] + (Delta * AdditiveAlpha);
        }
    }
};
```

---

## í™•ì¥ ê°€ì´ë“œ

### ìƒˆë¡œìš´ Transition Rule ì¶”ê°€

1. **UAnimNodeTransitionRule ìƒì†**
```cpp
class UMyCustomRule : public UAnimNodeTransitionRule
{
    DECLARE_CLASS(UMyCustomRule, UAnimNodeTransitionRule)
public:
    virtual bool CheckTransitionRule() override
    {
        // ì»¤ìŠ¤í…€ ë¡œì§ êµ¬í˜„
        return /* ì¡°ê±´ */;
    }
};
```

2. **AnimInstanceì— ë“±ë¡**
```cpp
UMyCustomRule* Rule = NewObject<UMyCustomRule>();
AddTransitionRule(Rule);
```

---

### ìƒˆë¡œìš´ ì• ë‹ˆë©”ì´ì…˜ ë…¸ë“œ ì¶”ê°€

1. **FAnimNode_Base ìƒì†**
```cpp
struct FAnimNode_MyCustomNode : FAnimNode_Base
{
    // ë©¤ë²„ ë³€ìˆ˜
    FAnimNode_Base* InputNode = nullptr;
    float CustomParameter = 0.0f;

    virtual void Update(const FAnimationUpdateContext& Context) override
    {
        // ì—…ë°ì´íŠ¸ ë¡œì§
    }

    virtual void Evaluate(FPoseContext& Output) override
    {
        // Pose ê³„ì‚° ë¡œì§
    }
};
```

2. **State Machineì— í†µí•©**
```cpp
// StateMachineì˜ ë…¸ë“œ ê·¸ë˜í”„ì— ì¶”ê°€
MyCustomNode.InputNode = &SequenceNode;
RootNode = &MyCustomNode;
```

---

### ì• ë‹ˆë©”ì´ì…˜ ë°ì´í„° í™•ì¥

**ì»¤ìŠ¤í…€ ë©”íƒ€ë°ì´í„° ì¶”ê°€**:
```cpp
struct FCustomAnimMetadata
{
    TArray<FAnimNotify> Notifies;        // ì• ë‹ˆë©”ì´ì…˜ ì´ë²¤íŠ¸
    TMap<FName, float> CustomCurves;     // ì»¤ìŠ¤í…€ ì»¤ë¸Œ
};

class UAnimDataModel : public UObject
{
    FCustomAnimMetadata Metadata;  // ì¶”ê°€!
};
```

---

## ìµœì í™” íŒ

### 1. Pose ìºì‹±
```cpp
// ë™ì¼í•œ Poseë¥¼ ì—¬ëŸ¬ ë²ˆ ê³„ì‚°í•˜ì§€ ì•Šë„ë¡ ìºì‹±
TMap<float, FPoseContext> PoseCache;

FPoseContext& GetCachedPose(float Time)
{
    if (!PoseCache.Contains(Time))
    {
        FPoseContext NewPose(Skeleton);
        EvaluatePose(Time, NewPose);
        PoseCache.Add(Time, NewPose);
    }
    return PoseCache[Time];
}
```

### 2. Update ìµœì í™”
```cpp
// ê±°ë¦¬ ê¸°ë°˜ LOD
float DistanceToCamera = GetDistanceToCamera();
if (DistanceToCamera > 50.0f)
{
    // ë¨¼ ê±°ë¦¬: Update ìŠ¤í‚µ
    return;
}
else if (DistanceToCamera > 20.0f)
{
    // ì¤‘ê°„ ê±°ë¦¬: ë‚®ì€ í”„ë ˆì„ë ˆì´íŠ¸ë¡œ Update
    if (FrameCount % 2 == 0) return;
}
// ê°€ê¹Œìš´ ê±°ë¦¬: ë§¤ í”„ë ˆì„ Update
```

### 3. ë©”ëª¨ë¦¬ ìµœì í™”
```cpp
// ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì• ë‹ˆë©”ì´ì…˜ ì–¸ë¡œë“œ
void UnloadUnusedAnimations()
{
    for (auto* Anim : LoadedAnimations)
    {
        if (Anim->GetRefCount() == 0)
        {
            RESOURCE.Unload(Anim);
        }
    }
}
```

---

## ë””ë²„ê¹… íŒ

### 1. State Machine ì‹œê°í™”
```cpp
void DebugDrawStateMachine()
{
    FString CurrentStateName = ASM.CurrentState ? ASM.CurrentState->Name.ToString() : "None";
    DrawDebugString(World, Location, CurrentStateName, Color::Green);

    if (ASM.bIsInTransition)
    {
        FString TransitionInfo = FString::Printf("Transition: %.2f/%.2f",
                                                  ASM.TransitionElapsed,
                                                  ASM.TransitionDuration);
        DrawDebugString(World, Location + FVector(0, 0, 50), TransitionInfo, Color::Yellow);
    }
}
```

### 2. Pose ì‹œê°í™”
```cpp
void DebugDrawSkeleton()
{
    for (int i = 0; i < Skeleton->Bones.Num(); i++)
    {
        FTransform BoneTransform = GetBoneWorldTransform(i);
        DrawDebugSphere(World, BoneTransform.Position, 5.0f, 8, Color::Red);

        int ParentIndex = Skeleton->Bones[i].ParentIndex;
        if (ParentIndex >= 0)
        {
            FTransform ParentTransform = GetBoneWorldTransform(ParentIndex);
            DrawDebugLine(World, ParentTransform.Position, BoneTransform.Position, Color::White);
        }
    }
}
```

---

## ì°¸ê³  ìë£Œ

### ê´€ë ¨ íŒŒì¼
- `Animation/AnimInstance.h/cpp` - AnimInstance ê¸°ë³¸ êµ¬í˜„
- `Animation/AnimNode.h/cpp` - ì• ë‹ˆë©”ì´ì…˜ ë…¸ë“œ ì •ì˜
- `Animation/AnimationSequence.h/cpp` - ì• ë‹ˆë©”ì´ì…˜ ì‹œí€€ìŠ¤
- `Animation/AnimDataModel.h/cpp` - ì• ë‹ˆë©”ì´ì…˜ ë°ì´í„° ëª¨ë¸
- `Animation/AnimNodeTransitionRule.h/cpp` - Transition Rule
- `Animation/AnimSingleNodeInstance.h/cpp` - ë‹¨ì¼ ë…¸ë“œ ì¸ìŠ¤í„´ìŠ¤
- `Components/SkeletalMeshComponent.h/cpp` - ìŠ¤ì¼ˆë ˆíƒˆ ë©”ì‹œ ì»´í¬ë„ŒíŠ¸
- `Editor/FBXLoader.cpp` - FBX ì• ë‹ˆë©”ì´ì…˜ ë¡œë”©

### Unreal Engine ì°¸ì¡°
ì´ ì‹œìŠ¤í…œì€ Unreal Engineì˜ ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œì„ ì°¸ê³ í•˜ì—¬ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤:
- Animation Blueprint
- Animation State Machine
- Animation Nodes
- Pose Evaluation

---

**ì‘ì„±ì¼**: 2025ë…„ 11ì›” 18ì¼
**ë²„ì „**: 1.0
**ì‘ì„±ì**: Mundi Engine Team
