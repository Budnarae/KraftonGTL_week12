# 한글 경로 크래시 분석 및 해결 방법

## 문제 원인

### 1. **C++ 표준 라이브러리의 인코딩 불일치**

```cpp
// ❌ 크래시 발생 코드
std::ifstream InFile(ObjPath);  // ObjPath = "C:/한글/파일.obj" (UTF-8 문자열)
```

**문제점:**
- `std::ifstream`의 생성자는 **ANSI/ASCII 문자열**만 제대로 처리합니다.
- Windows에서 한글 경로는 **멀티바이트 문자열 (Multi-Byte Character Set, MBCS)**로 인코딩됩니다.
- UTF-8로 인코딩된 한글 문자열을 ANSI로 해석하면 **잘못된 바이트 시퀀스**로 인식됩니다.
- 결과: 파일을 찾지 못하거나, 잘못된 메모리 접근으로 **크래시**가 발생합니다.

### 2. **인코딩 변환 과정**

```
한글 경로: "C:/한글/파일.obj"
    ↓
UTF-8 인코딩: 0xED 0x95 0x9C 0xEA 0xB8 0x80 (6바이트)
    ↓
ANSI로 해석 시: ??? (인식 불가)
    ↓
파일 시스템 접근 실패 → 크래시
```

---

## 해결 방법: UTF-8 → UTF-16 변환

### 핵심 코드

```cpp
// ✅ 크래시 방지 코드
FWideString WPath = UTF8ToWide(ObjPath);  // UTF-8 → UTF-16 변환
std::ifstream InFile(WPath);              // UTF-16 경로로 파일 열기
```

### 코드 분석

#### **1. UTF8ToWide() 함수**
```cpp
FWideString UTF8ToWide(const FString& utf8Str)
{
    // UTF-8 문자열 → UTF-16(wstring) 변환
    // Windows API에서 wchar_t는 UTF-16으로 처리됨
}
```

**역할:**
- UTF-8 문자열(1~4바이트)을 UTF-16 문자열(2바이트)로 변환합니다.
- Windows 파일 시스템은 **내부적으로 UTF-16을 사용**하므로, 변환 후 정확한 경로 접근이 가능합니다.

**변환 예시:**
```
UTF-8:  "한" = 0xED 0x95 0x9C (3바이트)
UTF-16: "한" = 0xD55C (2바이트)
```

#### **2. std::ifstream 생성자 오버로드**
```cpp
std::ifstream InFile(WPath);  // WPath는 std::wstring (UTF-16)
```

**역할:**
- C++17부터 `std::ifstream`은 `std::wstring`을 받는 생성자를 지원합니다.
- UTF-16 경로를 Windows 파일 시스템에 직접 전달하여 한글 경로를 올바르게 처리합니다.

#### **3. fs::path와 wstring()**
```cpp
fs::path FullPath = fs::weakly_canonical(BaseDir / MtlFileName);
FWideString PathStr = FullPath.wstring();  // fs::path → std::wstring
```

**역할:**
- `fs::path`는 플랫폼 독립적인 경로 객체입니다.
- `wstring()` 메서드로 **UTF-16 경로 문자열**을 추출합니다.
- Windows에서 경로 구분자를 `\`에서 `/`로 정규화합니다.

---

## 전체 코드 흐름 분석

```cpp
bool GetMtlDependencies(const FString& ObjPath, TArray<FWideString>& OutMtlFilePaths)
{
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 1단계: UTF-8 → UTF-16 변환
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    FWideString WPath = UTF8ToWide(ObjPath);  // "C:/한글/파일.obj" → L"C:/한글/파일.obj"

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 2단계: UTF-16 경로로 파일 열기
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    std::ifstream InFile(WPath);  // Windows가 UTF-16을 올바르게 처리
    if (!InFile.is_open())
    {
        UE_LOG("Failed to open .obj file for dependency scan: %s", ObjPath.c_str());
        return false;
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 3단계: 부모 디렉토리 경로 추출
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    fs::path BaseDir = fs::path(ObjPath).parent_path();  // "C:/한글/파일.obj" → "C:/한글"
    FString Line;

    while (std::getline(InFile, Line))
    {
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 4단계: 라인 앞뒤 공백 제거 (안정성 향상)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        Line.erase(0, Line.find_first_not_of(" \t\r\n"));          // 앞쪽 공백 제거
        Line.erase(Line.find_last_not_of(" \t\r\n") + 1);           // 뒤쪽 공백 제거

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 5단계: "mtllib " 선언 파싱
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        if (Line.rfind("mtllib ", 0) == 0)  // 라인이 "mtllib "로 시작하는지 확인
        {
            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // 6단계: 파일 이름 추출
            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            FString MtlFileName = Line.substr(7);  // "mtllib material.mtl" → "material.mtl"
            if (!MtlFileName.empty())
            {
                // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                // 7단계: 상대 경로 → 절대 경로 변환
                // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                fs::path FullPath = fs::weakly_canonical(BaseDir / MtlFileName);
                // "C:/한글" + "material.mtl" → "C:/한글/material.mtl"

                // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                // 8단계: fs::path → UTF-16 문자열 변환
                // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                FWideString PathStr = FullPath.wstring();  // UTF-16 경로 추출

                // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                // 9단계: 경로 구분자 정규화 (Windows 호환성)
                // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                std::replace(PathStr.begin(), PathStr.end(), '\\', '/');
                // "C:\한글\material.mtl" → "C:/한글/material.mtl"

                // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                // 10단계: 중복 제거 후 배열에 추가
                // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                OutMtlFilePaths.AddUnique(NormalizePath(PathStr));
            }
        }
    }
    return true;
}
```

---

## 각 단계별 핵심 역할

| 단계 | 코드 | 역할 |
|------|------|------|
| **1** | `UTF8ToWide(ObjPath)` | UTF-8 → UTF-16 변환 (한글 경로 지원) |
| **2** | `std::ifstream InFile(WPath)` | UTF-16 경로로 파일 열기 (크래시 방지) |
| **3** | `fs::path::parent_path()` | 부모 디렉토리 추출 |
| **4** | `Line.erase(...)` | 공백 제거 (파싱 안정성 향상) |
| **5** | `rfind("mtllib ", 0)` | "mtllib " 선언 탐지 |
| **6** | `Line.substr(7)` | 파일 이름 추출 |
| **7** | `fs::weakly_canonical()` | 상대 경로 → 절대 경로 변환 |
| **8** | `FullPath.wstring()` | fs::path → UTF-16 문자열 |
| **9** | `std::replace()` | 경로 구분자 정규화 (\ → /) |
| **10** | `AddUnique()` | 중복 제거 후 배열 추가 |

---

## 왜 이 코드를 안 쓰면 크래시가 나는가?

### ❌ **문제 코드**
```cpp
std::ifstream InFile(ObjPath);  // ObjPath = "C:/한글/파일.obj" (UTF-8)
```

**크래시 발생 과정:**
1. `std::ifstream` 생성자가 UTF-8 문자열을 **ANSI로 해석**
2. 한글 바이트 시퀀스(`0xED 0x95 0x9C`)를 잘못된 문자로 인식
3. Windows 파일 시스템이 경로를 찾지 못함
4. **파일 열기 실패** → `InFile.is_open() == false`
5. 이후 `std::getline(InFile, Line)` 호출 시 **정의되지 않은 동작 (Undefined Behavior)**
6. **메모리 접근 위반 (Access Violation)** → **크래시!**

### ✅ **해결 코드**
```cpp
FWideString WPath = UTF8ToWide(ObjPath);  // UTF-8 → UTF-16
std::ifstream InFile(WPath);              // UTF-16 경로로 파일 열기
```

**안전한 동작:**
1. UTF-8 → UTF-16 변환으로 **정확한 경로 표현**
2. Windows 파일 시스템이 UTF-16을 **네이티브로 지원**
3. 파일 열기 성공 → 안전한 파싱

---

## 추가 고려사항

### 1. **NormalizePath() 함수**
```cpp
OutMtlFilePaths.AddUnique(NormalizePath(PathStr));
```
- 경로를 표준 형식으로 정규화 (대소문자, 슬래시 방향, 상대 경로 제거)
- 중복 경로를 정확하게 탐지하기 위함

### 2. **fs::weakly_canonical() vs fs::canonical()**
```cpp
fs::path FullPath = fs::weakly_canonical(BaseDir / MtlFileName);
```
- `fs::canonical()`: 파일이 **존재하지 않으면 예외 발생**
- `fs::weakly_canonical()`: 파일이 없어도 **경로를 정규화**하여 반환 (더 안전)

---

## 결론

**한글 경로 크래시 방지를 위해서는:**

1. ✅ **모든 파일 열기 코드에서 UTF-8 → UTF-16 변환 사용**
   ```cpp
   FWideString WPath = UTF8ToWide(FilePath);
   std::ifstream InFile(WPath);
   ```

2. ✅ **fs::path의 wstring() 메서드 사용**
   ```cpp
   FWideString PathStr = fsPath.wstring();
   ```

3. ✅ **경로 구분자 정규화**
   ```cpp
   std::replace(PathStr.begin(), PathStr.end(), '\\', '/');
   ```

**이 패턴을 따르지 않으면**, 한글이 포함된 경로에서 **100% 크래시**가 발생합니다!

---

## Content Drawer 수정 필요 부분

다음 섹션에서 Content Drawer의 모든 파일 열기 코드를 검사하고, 위의 패턴을 적용하여 한글 경로 크래시를 방지합니다.
